---
title: 'Deployment di Applicazioni React'
description: 'Come preparare e deployare applicazioni React per la produzione, inclusi lazy loading, build e configurazione per client-side routing'
date: 2026-01-19
tags: ['formazione']
authors: ['vitoesposito']
order: 18
---

## Introduzione

Il deployment di un'applicazione React consiste nel preparare il codice per la produzione e pubblicarlo su un server accessibile agli utenti. Questo processo include ottimizzazione del codice, build per produzione e configurazione del server per gestire correttamente il routing client-side. Questo articolo esplora come funziona il processo di deployment, le tecniche di ottimizzazione come il lazy loading e la configurazione necessaria per applicazioni single-page.

## Processo di Deployment

Il deployment di un'applicazione React segue questi passaggi: test del codice, ottimizzazione, build per produzione e upload su un server.

### Test e Ottimizzazione

Prima del deployment, è importante testare l'applicazione e identificare opportunità di ottimizzazione. Il lazy loading è una tecnica comune per ridurre il tempo di caricamento iniziale.

### Build per Produzione

Il codice sviluppato non è quello che viene deployato. Durante lo sviluppo si usa codice leggibile con JSX e altre funzionalità che devono essere trasformate. Il build process produce un bundle ottimizzato e minificato pronto per la produzione.

### Upload e Configurazione

Il bundle prodotto viene caricato su un hosting provider. Per applicazioni React single-page, serve un **static site host** che serve file HTML, CSS e JavaScript senza eseguire codice lato server.

## Lazy Loading

Il **lazy loading** carica componenti solo quando necessari, invece di caricare tutto il codice all'inizio. Questo riduce il tempo di caricamento iniziale.

### Come Funziona il Caricamento Standard

Senza lazy loading, tutti gli import vengono risolti prima di mostrare qualcosa sullo schermo:

```jsx
import BlogPage from './pages/Blog';
import { blogLoader } from './pages/Blog';

const router = createBrowserRouter([
  {
    path: '/blog',
    element: <BlogPage />,
    loader: blogLoader
  }
]);
```

Quando l'applicazione viene servita, tutti i file importati devono essere caricati prima che qualcosa venga visualizzato. In applicazioni complesse con molte route e componenti, questo può rallentare il caricamento iniziale.

### Implementazione del Lazy Loading

Per caricare un componente solo quando necessario, si usa `React.lazy` e `import()`:

```jsx
import { lazy, Suspense } from 'react';

// Caricamento lazy del componente
const BlogPage = lazy(() => import('./pages/Blog'));

// Caricamento lazy del loader
const router = createBrowserRouter([
  {
    path: '/blog',
    element: (
      <Suspense fallback={<p>Loading...</p>}>
        <BlogPage />
      </Suspense>
    ),
    loader: () => {
      return import('./pages/Blog').then(module => {
        return module.blogLoader();
      });
    }
  }
]);
```

`React.lazy` accetta una funzione che chiama `import()` dinamicamente. `import()` come funzione restituisce una Promise che si risolve con il modulo quando il codice viene caricato.

`Suspense` mostra un fallback mentre il componente viene caricato. Senza `Suspense`, si verificherebbe un errore perché `lazy` restituisce una Promise, non un componente valido.

<details class="my-4 rounded-lg border border-border bg-muted/30">
<summary class="cursor-pointer px-4 py-2 font-medium hover:bg-muted/50">Lazy loading con parametri nel loader</summary>
<div class="px-4 pb-4">

Quando il loader ha bisogno di parametri, si passa l'oggetto `meta` completo:

```jsx
{
  path: '/posts/:postId',
  element: (
    <Suspense fallback={<p>Loading...</p>}>
      <PostPage />
    </Suspense>
  ),
  loader: ({ params }) => {
    return import('./pages/Post').then(module => {
      return module.postLoader({ params });
    });
  }
}
```

L'oggetto `meta` contiene `params` e `request`, che vengono passati al loader importato dinamicamente.

</div>
</details>

### Verifica del Lazy Loading

Per verificare che il lazy loading funzioni, si apre la Network tab nelle DevTools del browser. Quando si naviga a una route caricata lazy, appare una richiesta per un file JavaScript aggiuntivo che viene scaricato dinamicamente.

## Build per Produzione

Il build process trasforma e ottimizza il codice per la produzione. Con Create React App, si esegue:

```bash
npm run build
```

Questo script:
- Trasforma il JSX in JavaScript standard
- Minifica il codice
- Ottimizza le dimensioni del bundle
- Separa il codice in chunk per il lazy loading
- Produce file pronti per il deployment

Il risultato è una cartella `build` contenente:
- `index.html`: file HTML principale
- `static/`: cartella con JavaScript, CSS e altri asset ottimizzati

Il contenuto della cartella `build` è quello che viene deployato sul server.

<details class="my-4 rounded-lg border border-border bg-muted/30">
<summary class="cursor-pointer px-4 py-2 font-medium hover:bg-muted/50">Struttura del build output</summary>
<div class="px-4 pb-4">

Il build produce file con nomi hashati per il cache busting:

```
build/
  ├── index.html
  └── static/
      ├── js/
      │   ├── main.[hash].js      # Codice principale
      │   ├── [chunk].[hash].js   # Chunk lazy-loaded
      │   └── ...
      ├── css/
      │   └── main.[hash].css
      └── media/
          └── ...
```

Gli hash nei nomi dei file garantiscono che quando il codice cambia, i browser scarichino la nuova versione invece di usare quella in cache.

</div>
</details>

## Deployment su Static Site Host

Le applicazioni React single-page sono **statiche**: consistono solo di file HTML, CSS e JavaScript che vengono eseguiti nel browser. Non richiedono un server che esegue codice.

Molti provider offrono hosting per siti statici: Firebase Hosting, Netlify, Vercel, GitHub Pages, AWS S3, ecc.

### Esempio: Firebase Hosting

Firebase Hosting è un esempio di provider per siti statici. Il processo di setup include:

1. **Installazione degli strumenti Firebase**:
```bash
npm install -g firebase-tools
```

2. **Login**:
```bash
firebase login
```

3. **Inizializzazione del progetto**:
```bash
firebase init
```

Durante l'inizializzazione, si seleziona:
- **Hosting** come feature
- Il progetto Firebase esistente o se ne crea uno nuovo
- La cartella `build` come directory da deployare
- **Yes** per configurare come single-page application

4. **Deploy**:
```bash
firebase deploy
```

Questo comando carica i file dalla cartella `build` sui server Firebase e fornisce un URL pubblico per accedere al sito.

## Configurazione per Client-Side Routing

Un aspetto critico del deployment è la configurazione del server per gestire correttamente il routing client-side.

### Client-Side vs Server-Side Routing

Con **server-side routing**, ogni path corrisponde a un file o una risorsa sul server. Quando si richiede `/blog`, il server cerca un file o una route corrispondente.

Con **client-side routing** (React Router), il routing viene gestito dal JavaScript nel browser. Il server deve sempre servire lo stesso file HTML indipendentemente dal path richiesto.

### Il Problema

Quando un utente inserisce direttamente un URL come `example.com/blog` o ricarica la pagina su quella route:

1. Il browser invia una richiesta HTTP al server per `/blog`
2. Per default, il server cerca un file o una route corrispondente a `/blog`
3. Non trovando nulla, il server restituisce un 404

Il server dovrebbe invece restituire sempre `index.html`, permettendo a React Router di gestire il routing nel browser.

### La Soluzione

Il server deve essere configurato per servire sempre `index.html` per qualsiasi path richiesto. Questo è chiamato **fallback a index.html** o configurazione per single-page application.

Con Firebase Hosting, rispondere "Yes" alla domanda "Configure as a single-page app?" configura automaticamente questa regola. La configurazione viene salvata in `firebase.json`:

```json
{
  "hosting": {
    "public": "build",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  }
}
```

La regola `rewrites` dice al server di servire `/index.html` per qualsiasi richiesta (`**`).

<details class="my-4 rounded-lg border border-border bg-muted/30">
<summary class="cursor-pointer px-4 py-2 font-medium hover:bg-muted/50">Configurazione manuale per altri provider</summary>
<div class="px-4 pb-4">

Se il provider non chiede automaticamente se configurare come single-page app, si deve configurare manualmente:

**Netlify**: creare `netlify.toml`:
```toml
[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200
```

**Nginx**: configurare il server:
```nginx
location / {
  try_files $uri $uri/ /index.html;
}
```

**Apache**: creare `.htaccess`:
```apache
<IfModule mod_rewrite.c>
  RewriteEngine On
  RewriteBase /
  RewriteRule ^index\.html$ - [L]
  RewriteCond %{REQUEST_FILENAME} !-f
  RewriteCond %{REQUEST_FILENAME} !-d
  RewriteRule . /index.html [L]
</IfModule>
```

</div>
</details>

## Riepilogo

Il deployment di un'applicazione React include test, ottimizzazione, build e upload su un server. Il **lazy loading** riduce il caricamento iniziale caricando componenti solo quando necessari usando `React.lazy` e `Suspense`.

Il **build process** trasforma e ottimizza il codice, producendo una cartella `build` con file pronti per la produzione. Le applicazioni React single-page sono statiche e richiedono solo un static site host.

La configurazione del server è critica per il **client-side routing**: il server deve servire sempre `index.html` per qualsiasi path, permettendo a React Router di gestire il routing nel browser. Senza questa configurazione, le route dirette o i refresh della pagina risultano in errori 404.

